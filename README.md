
---

# Документация проекта: Генератор описаний товаров Wildberries

## 1. Общее описание проекта

**Цель проекта:**  
Реализовать API для генерации уникальных SEO-описаний товаров Wildberries с использованием NLP-сервиса (GPT-4).  
Проект позволяет автоматически получать данные о товаре, формировать специальный промпт для генерации описания, запрашивать генерацию текста через GPT-4, проверять уникальность результата, сохранять полученные данные в базе данных и кэшировать результаты для ускорения повторных запросов.

**Основные функции:**
- Получение данных о товаре с публичного Wildberries API.
- Формирование промпта для генерации описания с учетом ключевых запросов, технических характеристик и требуемой тональности.
- Запрос к GPT-4 для генерации SEO-описания.
- Проверка уникальности сгенерированного текста.
- Сохранение шаблонов запросов (Prompt) и результатов генерации (GeneratedDescription) в PostgreSQL.
- Кэширование результатов с использованием Redis.
- Обработка ошибок (неверный SKU, проблемы сети, превышение лимита запросов, недоступность GPT-4).

---

## 2. Архитектура и компоненты

### 2.1. Основные модули и слои

- **Views (API Endpoint):**  
  Файл `description/views.py` содержит класс `GenerateDescriptionAPIView`, реализующий POST-эндпоинт `/api/generate-description/`, который:
  - Принимает JSON-запрос от клиента.
  - Валидирует данные через сериализатор `GenerateDescriptionSerializer`.
  - Проверяет наличие закэшированного результата.
  - Получает данные о товаре с Wildberries API через модуль `wb_utils`.
  - Формирует промпт для GPT-4 с помощью модуля `ai_utils`.
  - Выполняет запрос к GPT-4 через функцию `request_to_openai`.
  - Проверяет уникальность результата через `common_utils.check_uniqueness`.
  - Сохраняет запрос и результат в базе данных с помощью `bd_utils.save_prompt_and_description`.
  - Кэширует итоговый результат для ускорения повторных запросов.

- **Сериализатор:**  
  `GenerateDescriptionSerializer` (в файле `description/serializers.py`) определяет входящие параметры:
  - `sku_id`: идентификатор товара.
  - `tone`: тональность (выбор из "продающий", "формальный", "дружелюбный").
  - `language`: язык (по умолчанию "ru").
  - `exclude_keywords` и `include_keywords`: списки слов для исключения и включения соответственно.

- **Модули утилит:**
  - **wb_utils:**  
    Функция `get_sku_data(sku_id: str)` обращается к публичному Wildberries API и получает JSON с информацией о товаре. Если список продуктов пуст, выбрасывается ошибка.
  - **ai_utils:**  
    Содержит функции:
    - `generate_prompt(wb_data, request_data)`: формирует промпт на основе данных из Wildberries и параметров запроса.
    - `request_to_openai(prompt: str)`: отправляет запрос к GPT-4 (в нашем примере используется модель "gpt-4o-mini") и возвращает сгенерированный текст.
  - **common_utils:**  
    Функция `check_uniqueness(description)` вычисляет уникальность сгенерированного описания (на данный момент возвращается значение, например, 95).
  - **cache_utils:**  
    Функции для работы с кэшированием через Redis (генерация ключа, установка и получение закэшированного результата).
  - **bd_utils:**  
    Функция `save_prompt_and_description(...)` сохраняет или обновляет записи в базе данных. Модель `Prompt` хранит параметры запроса, а `GeneratedDescription` — сгенерированное описание.

### 2.2. Модели базы данных

- **Prompt:**  
  Хранит информацию о запросе генерации:
  - `sku_id`, `tone`, `language` — уникальное сочетание.
  - `exclude_keywords` и `include_keywords` (JSON-поля).
  - `created_at` — время создания.
  
  Определено уникальное ограничение (UniqueConstraint) по полям `sku_id`, `tone` и `language`.

- **GeneratedDescription:**  
  Связана с `Prompt` через OneToOneField. Содержит:
  - `description` — сгенерированный текст.
  - `generated_at` — время генерации.

### 2.3. Внешние сервисы

- **Wildberries API:**  
  Используется публичный эндпоинт для получения данных о товаре по его SKU.
  
- **OpenAI API (GPT-4):**  
  Запрос к GPT-4 для генерации SEO-описания на основе сформированного промпта.
  
- **Redis:**  
  Используется для кэширования результатов, чтобы снизить нагрузку на GPT-4 и ускорить повторные запросы.
  
- **PostgreSQL:**  
  База данных для хранения записей с шаблонами запросов (Prompt) и сгенерированными описаниями (GeneratedDescription).

---

## 3. API Endpoints

### 3.1. POST /api/generate-description/

**Описание:**  
Генерирует уникальное SEO-описание для товара на основе его SKU и переданных параметров.

**Параметры запроса (JSON):**
```json
{
  "sku_id": "123456",
  "tone": "продающий",
  "language": "ru",
  "exclude_keywords": ["дешевый", "скидка"],
  "include_keywords": ["теплая", "зимняя"]
}
```

**Пример ответа:**
```json
{
  "description": "Сгенерированное SEO-описание для товара...",
  "unique_score": 95
}
```

**Ошибки:**
- 400 — неверный SKU или отсутствие данных.
- 503 — сервис GPT-4 недоступен или ошибка сети.

**Порядок работы эндпоинта:**
1. Валидируются входные данные с помощью `GenerateDescriptionSerializer`.
2. Если в кэше уже есть результат для данного набора параметров, возвращается кэшированный ответ.
3. Если кэш пуст:
   - Получаются данные о товаре через `wb_utils.get_sku_data`.
   - Формируется промпт с помощью `ai_utils.generate_prompt`.
   - Отправляется запрос к GPT-4 через `ai_utils.request_to_openai`.
   - Вычисляется уникальность через `common_utils.check_uniqueness`.
   - Сохраняется запись в базе данных через `bd_utils.save_prompt_and_description`.
   - Результат кэшируется на 5 минут.
4. Возвращается итоговый JSON-ответ.

---

## 4. Технические требования и развертывание

### 4.1. Стек технологий
- **Язык программирования:** Python 3.12
- **Фреймворк:** Django 5.1.6, Django REST Framework
- **База данных:** PostgreSQL (контейнер Postgres версии 15)
- **Кэш:** Redis (контейнер Redis версии 7)
- **NLP-сервис:** OpenAI API (GPT-4, модель "gpt-4o-mini")
- **Управление зависимостями:** Poetry
- **Контейнеризация:** Docker и docker-compose

### 4.2. Развёртывание через Docker

#### Файлы:
- **Dockerfile:** Сборка образа Django-приложения с Poetry, установкой системных зависимостей (gcc, libpq-dev, build-essential).
- **docker-compose.yml:** Описывает сервисы:
  - `db`: контейнер PostgreSQL.
  - `redis`: контейнер Redis.
  - `web`: контейнер с вашим Django-приложением.
- **.env:** Хранит переменные окружения:
  - OPENAI_API_KEY, DB_NAME, DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, REDIS_HOST, REDIS_PORT.

#### Пример команд для запуска:
1. Собрать и запустить контейнеры:
   ```bash
   docker-compose --env-file .env up --build
   ```
2. Для автоматического выполнения миграций и запуска сервера можно использовать скрипт-инициализатор (entrypoint.sh), который сначала выполняет миграции, а затем запускает сервер.

---

## 5. Пример последовательности работы

1. Клиент отправляет POST-запрос на `/api/generate-description/` с JSON-данными.
2. Сериализатор проверяет входные данные.
3. Если результат для данного запроса уже есть в Redis, возвращается кэшированный ответ.
4. Если кэш пуст:
   - Функция `wb_utils.get_sku_data` отправляет запрос к Wildberries и получает JSON с данными о товаре.
   - Функция `ai_utils.generate_prompt` формирует промпт для GPT-4, используя такие поля, как бренд, название товара, категория (entity) и переданные ключевые слова.
   - Функция `ai_utils.request_to_openai` отправляет сформированный промпт к OpenAI и получает сгенерированное описание.
   - Функция `common_utils.check_uniqueness` вычисляет уникальность описания.
   - Функция `bd_utils.save_prompt_and_description` сохраняет параметры запроса и результат генерации в PostgreSQL.
   - Результат кэшируется в Redis на 5 минут.
5. Возвращается JSON-ответ с полями `"description"` и `"unique_score"`.

---

## 6. Документация для разработчика

### 6.1. Swagger и Postman
- **Swagger:**  
  Документация API генерируется с помощью drf-yasg. В Swagger доступны все эндпоинты с примерами запросов и ответов.
- **Postman:**  
  Прикреплена коллекция Postman с готовыми запросами для тестирования эндпоинтов.

### 6.2. Запуск и тестирование
- **Локальный запуск с Docker:**  
  Используйте `docker-compose --env-file .env up --build`, чтобы поднять все сервисы.
- **Миграции и тесты:**  
  Миграции выполняются автоматически через entrypoint (или можно запускать их вручную через `docker-compose run web poetry run python manage.py migrate`).

---
